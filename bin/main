#!/usr/bin/env ruby

require_relative '../lib/player.rb'
require_relative '../lib/board.rb'

outputs = {
  ask_input: 'Write a letter from A to C and a number from 1 to 3',
  invalid_name: 'My master name can not be empty or just a number, let\'s try again! ',
  wrong: 'wrong input',
  taken: 'already taken',
  draw: 'it\'s a draw',
  winner: 'Congratulations you are the winner!',
  play_again: 'Do you want to keep playing? (y) to play again/ any key to exit'
}
input = ''
game_on = true
keep_going = true
valid_name = false
def welcome
  puts 'Welcome to the Tic Tac Toe game!'
  puts 'do you want to proceed? (y/n)'
  user_answer = gets.chomp.downcase
  if user_answer.match(/y/)
    true
  elsif user_answer.match(/n/)
    puts 'bye'
    false
  else
    puts 'wrong answer'
    welcome
  end
end

def instructions
  puts "Instructions:\n
   1)The game is played on a grid that's 3 squares by 3 squares.\n
   2)Write a letter from A to C\n
    and a number from 1 to 3 \n
    to select the row and the column respectively that you want to play on.\n
   3)Player 1 is X, player 2 is O.\n
   4)Once a player gets 3 marks in a row\n
    (up, down, across, or diagonally) is the winner.\n
   5)If all 9 squares are full, the game is over \n \n"
end

# game starts
while keep_going
  break unless welcome

  instructions

  until valid_name
    puts "Okay master! May I have first player's name?"
    player_name = gets.chomp
    valid_name = Player.valid_name?(player_name)
    unless valid_name
      puts outputs[:invalid_name]
      next
    end
    p1 = Player.new(player_name)
    puts "cool! #{p1.name}"
  end
  valid_name = false
  until valid_name
    puts "what about second player's name?"
    player_name = gets.chomp
    valid_name = Player.valid_name?(player_name)
    unless valid_name
      puts outputs[:invalid_name]
      next
    end
    p2 = Player.new(player_name)
    puts "cool! #{p2.name}, let's start to play "
  end

  board = Board.new
  puts board.p_board
  while game_on

    puts Player.whos_turn?
    loop do
      puts outputs[:ask_input]
      input = gets.chomp.upcase

      input_status = board.check_input(input)

      unless input_status == 'accepted'
        puts outputs[input_status.to_sym]
        next
      end

      board.modify(Player.current_player, input)
      puts board.p_board

      break
    end

    game_status = board.game_finish?(Player.current_player, input)

    if game_status
      puts outputs[game_status.to_sym]
      game_on = !game_on
    end
    Player.switch_player
  end
  puts outputs[:play_again]
  keep_going = Player.play_again?(gets.chomp.downcase)

end
