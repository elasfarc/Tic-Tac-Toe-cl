#!/usr/bin/env ruby
# rubocop:disable all
# frozen_string_literal: true
letter = ''
current_player = true 
def welcome
  puts 'Welcome to the Tic Tac Toe game!'
  puts 'do you want to proceed? (y/n)'
  user_answer = gets.chomp.downcase
  if user_answer.match(/y/)
    true
  elsif user_answer.match(/n/)
    puts 'bye'
    false
  else
    puts 'wrong answer'
    welcome
  end
end

def instructions
  puts "Instructions:\n 1)The game is played on a grid that's 3 squares by 3 squares.\n
   2)Write a letter from A to C and a number from 1 to 3 to select the row and the column respectively that you want to play on.\n
   3)Player 1 is X, player 2 is O.\n
   4)Once a player gets 3 marks in a row (up, down, across, or diagonally) is the winner.\n
   5)If all 9 squares are full, the game is over \n \n"
end

def players_setting1
  puts "Okay master! May I have first player's name?"
  user_answer = gets.chomp
  user_answer
end

def players_setting2(p1)
    puts "cool! #{p1}, what about second player's name?"
    user_answer = gets.chomp
    puts "cool! #{user_answer}, let's start to play "
    user_answer
end

def user_choice(letter, board, p1, p2, current_player)
  whos_turn?(p1, p2, current_player)
  puts 'Write a letter from A to C and a number from 1 to 3'
  payer_call = gets.chomp.upcase
  letter = symbol(current_player, letter)
  if payer_call.include? 'A'
    if payer_call.include? '1'
      board[0][0] == "_" ? board[0][0] = letter : invalid
    elsif payer_call.include? '2' 
      board[0][1] == "_" ? board[0][1] = letter : invalid
    elsif payer_call.include? '3' 
      board[0][2] == "_" ? board[0][2] = letter : invalid
    end 
  elsif payer_call.include? 'B' 
    if payer_call.include? '1' 
      board[1][0] == "_" ? board[1][0] = letter : invalid
    elsif payer_call.include? '2' 
      board[1][1] == "_" ? board[1][1] = letter : invalid
    elsif payer_call.include? '3' 
      board[1][2] == "_" ? board[1][2] = letter : invalid
    end 
  elsif payer_call.include? 'C' 
    if payer_call.include? '1' 
      board[2][0] == "_" ? board[2][0] = letter : invalid
    elsif payer_call.include? '2' 
      board[2][1] == "_" ? board[2][1] = letter : invalid
    elsif payer_call.include? '3'
      board[2][2] == "_" ? board[2][2] = letter : invalid
    end
  else
    puts 'Wrong input master'
  end
  board_matrix(board)
end

def board_matrix(board)
  puts "#{board[0][0]} #{board[0][1]} #{board[0][2]}"
  puts "#{board[1][0]} #{board[1][1]} #{board[1][2]}"
  puts "#{board[2][0]} #{board[2][1]} #{board[2][2]}"
end

def symbol(current_player, letter)
  if current_player
    letter = 'X'
  else
    letter = 'O'
  end
  letter
end

def whos_turn?(p1, p2, current_player)
  if current_player
    pp "okay #{p1} it's ur turn "

  else
    pp "okay #{p2} it's ur turn "
  end
end

def invalid
    puts "Not good, this position is already occupied"
end

def valid
    puts "Nice move"
end

first_row = %w[_ _ _]
second_row = %w[_ _ _]
third_row = %w[_ _ _]

board = [first_row, second_row, third_row]

# game starts

loop do
  break unless welcome

   instructions
   p1 = players_setting1
   p2 = players_setting2(p1)
   board_matrix(board)
   puts "\n"

  loop do
    user_choice(letter, board, p1, p2, current_player)
    current_player = !current_player
    # break unless game_finish
  end
end