# frozen_string_literal: true
letter = ''
current_player = true 
def welcome
  puts 'Welcome to the Tic Tac Toe game!'
  puts 'do you want to proceed? (y/n)'
  user_answer = gets.chomp.downcase
  if user_answer.match(/y/)
    true
  elsif user_answer.match(/n/)
    puts 'bye'
    false
  else
    puts 'wrong answer'
    welcome
  end
end

def instructions
  puts "Instructions:\n 1)The game is played on a grid that's 3 squares by 3 squares.\n
   2)Write a letter from A to C and a number from 1 to 3 to select the row and the column respectively that you want to play on.\n
   3)Player 1 is X, player 2 is O.\n
   4)Once a player gets 3 marks in a row (up, down, across, or diagonally) is the winner.\n
   5)If all 9 squares are full, the game is over \n \n"
end

def players_setting1
  puts "Okay master! May I have first player's name?"
  user_answer = gets.chomp
  user_answer
end

def players_setting2(p1)
    puts "cool! #{p1}, what about second player's name?"
    user_answer = gets.chomp
    puts "cool! #{user_answer}, let's start to play "
    user_answer
end

def mapping(move)
    move = move.to_sym
    board_hash = {A1: [0,0],
                  A2: [0,1],
                  A3: [0,2],
                  B1: [1,0],
                  B2: [1,1],
                  B3: [1,2],
                  C1: [2,0],
                  C2: [2,1],
                  C3: [2,2]
                } 
                board_hash[move]
end

def not_taken?(move)
    if move == "_"
        return true
    else
        return false
    end
end

def user_choice(board, current_player, p1, p2)
    whos_turn?(p1, p2, current_player)
    while true
        puts 'Write a letter from A to C and a number from 1 to 3'
        payer_call = gets.chomp.upcase
        
        letter= symbol(current_player, letter)

        from_mapping = mapping(payer_call)

        dummy_booleen = not_taken?(board[from_mapping[0]][from_mapping[1]])

        if dummy_booleen

        board[from_mapping[0]][from_mapping[1]] = letter
        break
        else
        puts "already taken"  
        end 
    end
    board_matrix(board)
    board
        
    #board_local[returned_array_from_mapping[0]][returned_array_from_mapping[1]] = "X"
    #return board_local[returned_array_from_mapping[0]][returned_array_from_mapping[1]]
end

def board_matrix(board)
  puts "#{board[0][0]} #{board[0][1]} #{board[0][2]}"
  puts "#{board[1][0]} #{board[1][1]} #{board[1][2]}"
  puts "#{board[2][0]} #{board[2][1]} #{board[2][2]}"
end

def symbol(current_player, letter)
  if current_player
    letter = 'X'
  else
    letter = 'O'
  end
  letter
end

def whos_turn?(p1, p2, current_player)
  if current_player
    pp "okay #{p1} it's ur turn "

  else
    pp "okay #{p2} it's ur turn "
  end
end

def invalid
    puts "Not good, this position is already occupied"
end

def valid
    puts "Nice move"
end

first_row = %w[_ _ _]
second_row = %w[_ _ _]
third_row = %w[_ _ _]

board = [first_row, second_row, third_row]

# game starts

loop do
  break unless welcome

   instructions
   p1 = players_setting1
   p2 = players_setting2(p1)
   board_matrix(board)
   puts "\n"

  loop do
    user_choice(board, current_player, p1, p2)
    current_player = !current_player
    # break unless game_finish
  end
end